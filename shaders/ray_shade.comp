#version 450
#pragma shader_stage(compute)

#include "bvh.glsl"
#include "wavefront_common.glsl"

layout(set = 0, binding = 1) uniform FrameState
{
	uint samplesPerFrame;
	uint totalSamples;
} frameState;

layout(set = 0, binding = 2) buffer AccumulatorBuffer	{ vec4 accumulator[]; };

layout(set = 1, binding = 0) coherent buffer RayCounters 					{ int rayIn; int rayOut; } rayCounters;
layout(set = 1, binding = 1) coherent buffer RayInBuffer 					{ Ray rays[]; } rayIn;
layout(set = 1, binding = 2) coherent buffer RayOutBuffer 					{ Ray rays[]; } rayOut;
layout(set = 1, binding = 3) coherent writeonly buffer ShadowRayCounter 	{ int rayCount; } shadowRayCounter;
layout(set = 1, binding = 4) coherent writeonly buffer ShadowRayBuffer 		{ ShadowRayMetadata rays[]; } shadowRays;

layout(set = 2, binding = 0) readonly uniform SceneData 		{ SceneBackground background; } sceneData;
layout(set = 2, binding = 1) readonly buffer TriBuffer 			{ Triangle triangles[]; };
layout(set = 2, binding = 2) readonly buffer TriExtBuffer 		{ TriExtension triExtensions[]; };
layout(set = 2, binding = 5) readonly buffer MaterialBuffer 	{ Material materials[]; };
layout(set = 2, binding = 6) readonly buffer InstanceBuffer 	{ Instance instances[]; };
layout(set = 2, binding = 9) readonly buffer LightBuffer		{ LightData lights[]; };

layout(local_size_x = 32, local_size_y = 32) in;

vec3 sceneNormal(Ray ray)
{
	Instance instance = instances[ray.hit.instanceIdx];
	return scaleNormalBarycentric(triExtensions[instance.triOffset + ray.hit.primitiveIdx], ray.hit.hitCoords);
}

Material sceneMaterial(Ray ray)
{
	Instance hitInstance = instances[ray.hit.instanceIdx];
	return materials[hitInstance.materialOffset];
}

void main()
{	
	const uvec3 GlobalWorkGroupSize = gl_NumWorkGroups * gl_WorkGroupSize;
	const uint InvocationIndex1D = gl_GlobalInvocationID.x + \
		gl_GlobalInvocationID.y * GlobalWorkGroupSize.x + \
		gl_GlobalInvocationID.z * GlobalWorkGroupSize.x * GlobalWorkGroupSize.y;

	uint seed = initSeed(InvocationIndex1D + frameState.totalSamples * 1799);
	int rayIdx = atomicAdd(rayCounters.rayIn, -1) - 1;
	if (rayIdx < 0)
	{
		atomicMax(rayCounters.rayIn, 0);
		return;
	}

	Ray ray = rayIn.rays[rayIdx];
	if (ray.depth == F32_FAR_AWAY)
	{
		ray.energy += ray.transmission * sampleSkyColor(ray, sceneData.background);
		accumulator[ray.state.pixelIdx] += vec4(ray.energy, 1);
		return;
	}

	Material material = sceneMaterial(ray);
	if (materialIsLight(material))
	{
		ray.energy += ray.state.lastSpecular ? ray.transmission * materialEmittance(material) : vec3(0);
		accumulator[ray.state.pixelIdx] += vec4(ray.energy, 1);
		return;
	}

	vec3 mediumScale = vec3(1.0);
	if (ray.state.inMedium)
		mediumScale = exp(material.absorption * -ray.depth);

	float p = clamp(max(ray.transmission.r, max(ray.transmission.g, ray.transmission.b)), 0.0, 1.0);
	if (p < randomF32(seed))
		return;

	vec3 I = rayHitPosition(ray);
	vec3 N = sceneNormal(ray);
	uint lightCount = lights.length();
	float rrScale = 1.0 / p;
	float rng = randomF32(seed);

	vec3 R = vec3(0);
	vec3 brdf = material.albedo * F32_INV_PI;

	if (dot(ray.direction, N) > 0.0f)
		N *= -1;

	if (rng < material.reflectivity)
	{
		R = reflect(ray.direction, N);
		ray.state.lastSpecular = true;
		ray.transmission *= material.albedo * rrScale * mediumScale;
	}
	else if (rng < (material.reflectivity + material.refractivity))
	{
		bool mustRefract = false;
		R = reflect(ray.direction, N);

		float n1 = ray.state.inMedium ? material.indexOfRefraction : 1.0;
        float n2 = ray.state.inMedium ? 1.0 : material.indexOfRefraction;
        float iorRatio = n1 / n2;

        float cosI = dot(-ray.direction, N);
        float cosTheta2 = 1.0 - (iorRatio * iorRatio) * (1.0 - cosI * cosI);
        float Fresnel = 1.0;

		if (cosTheta2 > 0.0f)
        {
			float a = n1 - n2, b = n1 + n2;
            float r0 = (a * a) / (b * b);
            float c = 1.0f - cosI;
            float Fresnel = r0 + (1.0f - r0) * (c * c * c * c * c);

			mustRefract = randomF32(seed) > Fresnel;
            if (mustRefract)
                R = iorRatio * ray.direction + ((iorRatio * cosI - sqrt(abs(cosTheta2))) * N);
		}

		ray.state.lastSpecular = true;
		ray.transmission *= material.albedo * rrScale * mediumScale;
		ray.state.inMedium = mustRefract ? !ray.state.inMedium : ray.state.inMedium;
	}
	else
	{
		R = diffuseReflectCosineWeighted(seed, N);
		float cosTheta = dot(N, R);
		float invCosTheta = 1.0 / cosTheta;
		float invPdf = F32_PI * invCosTheta;

		ray.state.lastSpecular = true;
		ray.transmission *= cosTheta * invPdf * brdf * mediumScale * rrScale;
	}

	vec3 O = I + F32_EPSILON * R;
	Ray bounce = newRay(O, R);
	copyRayMetadata(bounce, ray);
	rayOut.rays[atomicAdd(rayCounters.rayOut, 1)] = bounce;
}
