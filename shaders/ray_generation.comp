#version 450
#pragma shader_stage(compute)

#include "wavefront_common.glsl"

layout(set = 0, binding = 0) uniform CameraData
{
	vec3 position;
	vec3 topLeft;
	vec3 uVector;
	vec3 vVector;
	vec2 resolution;
} camera;

layout(set = 0, binding = 2, rgba8) uniform image2D outputImage;

layout(set = 1, binding = 0) buffer RayBuffer
{
	uint counter;
	Ray rays[];
} rayOut;

layout(local_size_x = 1, local_size_y = 1) in;

void main()
{
	uint xPixel = gl_WorkGroupID.x;
	uint yPixel = gl_WorkGroupID.y;
	uint pixelIdx = xPixel + gl_WorkGroupSize.x * yPixel;

	float u = xPixel / camera.resolution.x;
	float v = yPixel / camera.resolution.y;

	vec3 origin = camera.position;
	vec3 planePos = camera.topLeft + u * camera.uVector + v * camera.vVector;
	vec3 direction = normalize(planePos - origin);

	Ray newRay = Ray(
		origin,
		direction,
		F32_FAR_AWAY,
		pixelIdx,
		UNSET_IDX,
		UNSET_IDX,
		vec2(0, 0)
	);

	rayOut.rays[rayOut.counter] = newRay;
	atomicAdd(rayOut.counter, 1);
	
	// Temp output to storage image -> test if write works
	vec3 outColor = 0.5 * (vec3(1.0) + newRay.direction);
	imageStore(outputImage, ivec2(xPixel, yPixel), vec4(outColor, 1));
}
