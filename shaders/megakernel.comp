#version 450
#pragma shader_stage(compute)

#include "bvh.glsl"
#include "wavefront_common.glsl"

layout(set = 0, binding = 0) uniform CameraData
{
	vec3 position;
	vec3 firstPixel;
	vec3 uVector;
	vec3 vVector;
	vec2 resolution;
} camera;

layout(set = 0, binding = 1) uniform FrameState
{
	uint samplesPerFrame;
	uint totalSamples;
} frameState;

layout(set = 0, binding = 2) buffer AccumulatorBuffer
{
	vec4 accumulator[];
};

layout(set = 0, binding = 3, rgba8) uniform image2D outputImage;

layout(set = 2, binding = 0) uniform SceneData
{
	SceneBackground background;
} sceneData;

layout(set = 2, binding = 1) buffer TriangleBuffer
{
	Triangle triangles[];
} tris;

layout(set = 2, binding = 2) buffer BLASBuffer
{
	BvhNode nodes[];
} blas;

layout(set = 2, binding = 3) buffer InstanceBuffer
{
	Instance instances[];
} instances;

layout(set = 2, binding = 4) buffer TLASBuffer
{
	uint nodesUsed;
	BvhNode nodes[];
} tlas;

layout(local_size_x = 32, local_size_y = 32) in;

const vec3 albedo		= vec3(1, 0, 0);
const vec3 emittance	= vec3(0, 0, 0);

void main()
{
	uint xPixel = gl_LocalInvocationID.x + (gl_WorkGroupID.x * gl_WorkGroupSize.x);
	uint yPixel = gl_LocalInvocationID.y + (gl_WorkGroupID.y * gl_WorkGroupSize.y);
	uint pixelIdx = xPixel + (yPixel * (gl_NumWorkGroups.x * gl_WorkGroupSize.x));
	uint pixelSeed = initSeed(pixelIdx + frameState.totalSamples * 1799);

	for (uint s = 0; s < frameState.samplesPerFrame; s++)
	{
		float xAA = xPixel + randomRange(pixelSeed, -0.5, 0.5);
		float yAA = yPixel + randomRange(pixelSeed, -0.5, 0.5);

		float u = xAA / camera.resolution.x;
		float v = yAA / camera.resolution.y;

		vec3 origin = camera.position;
		vec3 planePos = camera.firstPixel + u * camera.uVector + v * camera.vVector;
		vec3 direction = normalize(planePos - origin);

		Ray activeRay = newRay(origin, direction);

		vec3 energy = vec3(0);
		for (uint bounceCount = 0;;bounceCount++)
		{
			// TODO: actual scene intersect with BVH TLAS / BLAS
			if (!sceneIntersect(activeRay))
			{
				energy += activeRay.transmission * sampleSkyColor(activeRay, sceneData.background);
				break;
			}

			vec3 I = rayHitPosition(activeRay);
			vec3 N = sceneNormal(activeRay);
			vec2 texCoords = vec2(0, 0);
			Material material = Material(
				vec3(0, 0, 0), 0.0,		// Emission color & strength
				vec3(0.2, 0.2, 0.2),	// Albedo
				vec3(0.02, 0.02, 0.02),	// Absorption
				0.0, 0.0,				// Reflectivity & Refractivity
				1.05					// IOR
			);

			if (materialIsLight(material))
			{
				energy += activeRay.transmission * materialEmittance(material);
				break;
			}

			float p = clamp(max(activeRay.transmission.r, max(activeRay.transmission.g, activeRay.transmission.b)), 0.0f, 1.0f);
			if (bounceCount <= 2)	// Don't RR on first 2 bounces
				p = 1.0;

			if (p < randomF32(pixelSeed))
				break;

			if (dot(activeRay.direction, N) > 0.0f)
				N *= -1;

			vec3 mediumScale = vec3(1.0);
			if (activeRay.inMedium)
				mediumScale = exp(material.absorption * -activeRay.depth);

			float rrScale = 1.0 / p;
			float r = randomF32(pixelSeed);
			if (r < material.reflectivity)
			{
				vec3 newDirection = reflect(activeRay.direction, N);
				vec3 newOrigin = I + F32_EPSILON * newDirection;
				Ray reflectRay = newRay(newOrigin, newDirection);

				activeRay.transmission *= material.albedo * mediumScale * rrScale;
				reflectRay.pixelIdx = activeRay.pixelIdx;
				reflectRay.inMedium = activeRay.inMedium;
				reflectRay.transmission = activeRay.transmission;
				activeRay = reflectRay;
			}
			else if (r < (material.reflectivity + material.refractivity))
			{
				float n1 = activeRay.inMedium ? material.indexOfRefraction : 1.0f;
				float n2 = activeRay.inMedium ? 1.0f : material.indexOfRefraction;
				float iorRatio = n1 / n2;

				float cosI = dot(-activeRay.direction, N);
				float cosTheta2 = 1.0f - iorRatio * iorRatio * (1.0f - cosI * cosI);
				float Fresnel = 1.0f;
				if (cosTheta2 > 0.0f)
				{
					float a = n1 - n2;
					float b = n1 + n2;
					float r0 = (a * a) / (b * b);
					float c = 1.0f - cosI;
					float Fresnel = r0 + (1.0f - r0) * (c * c * c * c * c);

					vec3 newDirection = iorRatio * activeRay.direction + ((iorRatio * cosI - sqrt(abs(cosTheta2))) * N);
					vec3 newOrigin = I + F32_EPSILON * newDirection;
					Ray transmitRay = newRay(newOrigin, newDirection);

					if (randomF32(pixelSeed) > Fresnel)
					{
						activeRay.transmission *= material.albedo * mediumScale * rrScale;
						transmitRay.pixelIdx = activeRay.pixelIdx;
						transmitRay.inMedium = !activeRay.inMedium;
						transmitRay.transmission = activeRay.transmission;
						activeRay = transmitRay;
						continue;
					}
				}

				vec3 newDirection = reflect(activeRay.direction, N);
				vec3 newOrigin = I + F32_EPSILON * newDirection;
				Ray reflectRay = newRay(newOrigin, newDirection);

				activeRay.transmission *= material.albedo * mediumScale * rrScale;
				reflectRay.pixelIdx = activeRay.pixelIdx;
				reflectRay.inMedium = activeRay.inMedium;
				reflectRay.transmission = activeRay.transmission;
				activeRay = reflectRay;
			}
			else
			{
				// handle diffuse BRDF
				vec3 newDirection = diffuseReflect(pixelSeed, N);
				vec3 newOrigin = I + F32_EPSILON * newDirection;
				Ray bounceRay = newRay(newOrigin, newDirection);

				float cosTheta = dot(newDirection, N);
				vec3 brdf = material.albedo * F32_INV_PI;
				float inversePdf = F32_2PI;

				activeRay.transmission *= materialEmittance(material) + inversePdf * cosTheta * brdf * mediumScale * rrScale;
				bounceRay.pixelIdx = activeRay.pixelIdx;
				bounceRay.inMedium = activeRay.inMedium;
				bounceRay.transmission = activeRay.transmission;
				activeRay = bounceRay;
			}
		}

		accumulator[pixelIdx] += vec4(energy, 1);
	}

	float invSamples = 1.0 / frameState.totalSamples;
	imageStore(
		outputImage,
		ivec2(xPixel, yPixel),
		accumulator[pixelIdx] * invSamples
	);
}
