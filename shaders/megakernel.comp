#version 450
#pragma shader_stage(compute)

#include "bvh.glsl"
#include "wavefront_common.glsl"

layout(set = 0, binding = 0) uniform CameraData
{
	vec3 position;
	vec3 firstPixel;
	vec3 uVector;
	vec3 vVector;
	vec2 resolution;
} camera;

layout(set = 0, binding = 1) uniform FrameState
{
	uint samplesPerFrame;
	uint totalSamples;
} frameState;

layout(set = 0, binding = 2) buffer AccumulatorBuffer
{
	vec4 accumulator[];
};

layout(set = 0, binding = 3, rgba8) uniform image2D outputImage;

layout(set = 2, binding = 0) uniform SceneData
{
	SceneBackground background;
} sceneData;

layout(set = 2, binding = 1) buffer TriangleBuffer
{
	Triangle triangles[];
} tris;

layout(set = 2, binding = 2) buffer BLASBuffer
{
	BvhNode nodes[];
} blas;

layout(set = 2, binding = 3) buffer InstanceBuffer
{
	Instance instances[];
} instances;

layout(set = 2, binding = 4) buffer TLASBuffer
{
	uint nodesUsed;
	BvhNode nodes[];
} tlas;

layout(local_size_x = 32, local_size_y = 32) in;

const vec3 albedo		= vec3(1, 0, 0);
const vec3 emittance	= vec3(0, 0, 0);

void main()
{
	uint xPixel = gl_LocalInvocationID.x + (gl_WorkGroupID.x * gl_WorkGroupSize.x);
	uint yPixel = gl_LocalInvocationID.y + (gl_WorkGroupID.y * gl_WorkGroupSize.y);
	uint pixelIdx = xPixel + (yPixel * (gl_NumWorkGroups.x * gl_WorkGroupSize.x));
	uint pixelSeed = initSeed(pixelIdx + frameState.totalSamples * 1799);

	for (uint s = 0; s < frameState.samplesPerFrame; s++)
	{
		float xAA = xPixel + randomRange(pixelSeed, -0.5, 0.5);
		float yAA = yPixel + randomRange(pixelSeed, -0.5, 0.5);

		float u = xAA / camera.resolution.x;
		float v = yAA / camera.resolution.y;

		vec3 origin = camera.position;
		vec3 planePos = camera.firstPixel + u * camera.uVector + v * camera.vVector;
		vec3 direction = normalize(planePos - origin);

		Ray ray = Ray(
			origin,
			direction,
			F32_FAR_AWAY,
			vec3(1),
			pixelIdx,
			UNSET_IDX,
			vec2(0, 0)
		);

		vec3 energy = vec3(0);
		while(true)
		{
			// TODO: actual scene intersect with BVH TLAS / BLAS
			if (!sphereIntersect(ray))
			{
				energy = ray.transmission * sampleSkyColor(ray, sceneData.background);
				break;
			}

			vec3 I = rayHitPosition(ray);
			vec3 N = sphereNormal(rayHitPosition(ray));
			vec2 texCoords = vec2(0, 0);

			if (dot(ray.direction, N) > 0.0f)
				N *= -1;

			// TODO: add randomized reflectivity & refractivity

			// calculate BRDF and new direction
			vec3 newDirection = diffuseReflect(pixelSeed, N);
			vec3 newOrigin = I + F32_EPSILON * newDirection;
			ray = Ray(
				newOrigin,
				newDirection,
				F32_FAR_AWAY,
				ray.transmission,
				pixelIdx,
				UNSET_IDX,
				vec2(0, 0)
			);

			float cosTheta = dot(newDirection, N);
			vec3 brdf = albedo * F32_INV_PI;
			float inversePdf = F32_2PI;

			ray.transmission *= emittance + inversePdf * cosTheta * brdf;
		}

		accumulator[pixelIdx] += vec4(energy, 1);
	}

	float invSamples = 1.0 / frameState.totalSamples;
	imageStore(
		outputImage,
		ivec2(xPixel, yPixel),
		accumulator[pixelIdx] * invSamples
	);
}
