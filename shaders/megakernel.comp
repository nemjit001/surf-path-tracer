#version 450
#pragma shader_stage(compute)

#include "bvh.glsl"
#include "wavefront_common.glsl"

#define TLAS_ROOT_IDX			0
#define TRAVERSAL_STACK_SIZE 	64

layout(set = 0, binding = 0) uniform CameraData
{
	vec3 position;
	vec3 up;
	vec3 fwd;
	vec3 right;
	vec3 firstPixel;
	vec3 uVector;
	vec3 vVector;
	vec2 resolution;
	float focalLength;
	float defocusAngle;
} camera;

layout(set = 0, binding = 1) uniform FrameState
{
	uint samplesPerFrame;
	uint totalSamples;
} frameState;

layout(set = 0, binding = 2) buffer AccumulatorBuffer	{ vec4 accumulator[]; };
layout(set = 0, binding = 3, rgba8) uniform image2D outputImage;

layout(set = 2, binding = 0) uniform SceneData 		{ SceneBackground background; } sceneData;
layout(set = 2, binding = 1) buffer TriBuffer 		{ Triangle triangles[]; };
layout(set = 2, binding = 2) buffer TriExtBuffer 	{ TriExtension triExtensions[]; };
layout(set = 2, binding = 3) buffer BLASIndexBuffer { uint blasIndices[]; };
layout(set = 2, binding = 4) buffer BLASNodeBuffer 	{ BvhNode blasNodes[]; };
layout(set = 2, binding = 5) buffer MaterialBuffer 	{ Material materials[]; };
layout(set = 2, binding = 6) buffer InstanceBuffer 	{ Instance instances[]; };
layout(set = 2, binding = 7) buffer TLASIndexBuffer { uint tlasIndices[]; };
layout(set = 2, binding = 8) buffer TLASNodeBuffer 	{ BvhNode tlasNodes[]; };

layout(local_size_x = 32, local_size_y = 32) in;

bool intersectBLAS(Instance instance, inout Ray ray)
{
	BvhNode node = blasNodes[instance.nodeOffset];
	uint stack[TRAVERSAL_STACK_SIZE];
	uint stackptr = 0;
	bool intersected = false;

	while(true)
	{
		if (bvhNodeIsLeaf(node))
		{
			for (uint i = 0; i < node.count; i++)
			{
				uint primIdx = blasIndices[instance.idxOffset + node.leftFirst + i];
				if (triangleIntersect(triangles[instance.triOffset + primIdx], ray))
				{
					ray.hit.primitiveIdx = primIdx;
					intersected = true;
				}
			}

			if (stackptr == 0)
				break;

			node = blasNodes[stack[stackptr - 1]];
			stackptr--;
			continue;
		}

		uint childNearIdx = instance.nodeOffset + node.leftFirst;
		uint childFarIdx = childNearIdx + 1;
		float distNear = aabbIntersect(blasNodes[childNearIdx], ray);
		float distFar = aabbIntersect(blasNodes[childFarIdx], ray);

		if (distNear > distFar)
		{
			uint ti = childNearIdx; childNearIdx = childFarIdx; childFarIdx = ti;
			float td = distNear; distNear = distFar; distFar = td;
		}

		if (distNear == F32_FAR_AWAY)
		{
			if (stackptr == 0)
				break;
			
			node = blasNodes[stack[stackptr - 1]];
			stackptr--;
		}
		else
		{
			node = blasNodes[childNearIdx];
			if (distFar != F32_FAR_AWAY)
			{
				stack[stackptr] = childFarIdx;
				stackptr++;
			}
		}
	}

	return intersected;
}

bool intersectInstance(Instance instance, inout Ray ray)
{
	Ray oldRay = ray;

	vec4 tPos = instance.invTransform * vec4(ray.origin, 1);
	vec4 tDir = instance.invTransform * vec4(ray.direction, 0);

	ray.origin = tPos.xyz / tPos.w;
	ray.direction = tDir.xyz;

	bool intersected = intersectBLAS(instance, ray);
	ray.origin = oldRay.origin;
	ray.direction = oldRay.direction;

	return intersected;
}

bool intersectTLAS(inout Ray ray)
{
	BvhNode node = tlasNodes[TLAS_ROOT_IDX];
	uint stack[TRAVERSAL_STACK_SIZE];
	uint stackptr = 0;
	bool intersected = false;

	while(true)
	{
		if (bvhNodeIsLeaf(node))
		{
			for (uint i = 0; i < node.count; i++)
			{
				uint instanceIdx = tlasIndices[node.leftFirst + i];
				if (intersectInstance(instances[instanceIdx], ray))
				{
					ray.hit.instanceIdx = instanceIdx;
					intersected = true;
				}
			}

			if (stackptr == 0)
				break;

			node = tlasNodes[stack[stackptr - 1]];
			stackptr--;
			continue;
		}

		uint childNearIdx = node.leftFirst;
		uint childFarIdx = childNearIdx + 1;
		float distNear = aabbIntersect(tlasNodes[childNearIdx], ray);
		float distFar = aabbIntersect(tlasNodes[childFarIdx], ray);

		if (distNear > distFar)
		{
			uint ti = childNearIdx; childNearIdx = childFarIdx; childFarIdx = ti;
			float td = distNear; distNear = distFar; distFar = td;
		}

		if (distNear == F32_FAR_AWAY)
		{
			if (stackptr == 0)
				break;
			
			node = tlasNodes[stack[stackptr - 1]];
			stackptr--;
		}
		else
		{
			node = tlasNodes[childNearIdx];
			if (distFar != F32_FAR_AWAY)
			{
				stack[stackptr] = childFarIdx;
				stackptr++;
			}
		}
	}

	return intersected;
}

vec3 sceneNormal(Ray ray)
{
	Instance instance = instances[ray.hit.instanceIdx];
	return scaleNormalBarycentric(triExtensions[instance.triOffset + ray.hit.primitiveIdx], ray);
}

Material sceneMaterial(Ray ray)
{
	Instance hitInstance = instances[ray.hit.instanceIdx];
	return materials[hitInstance.materialOffset];
}

vec3 sampleDefocusDisk(inout uint seed)
{
	const float radius = camera.focalLength * tan(radians(camera.defocusAngle / 2.0));
	const vec3 u = camera.right * radius;
	const vec3 v = -camera.up * radius;

	vec2 diskSample = vec2(0);
	do 
	{
		diskSample = vec2(
			randomRange(seed, -1.0, 1.0),
			randomRange(seed, -1.0, 1.0)
		);
	} while(dot(diskSample, diskSample) > 1.0);

	return diskSample.x * u + diskSample.y * v;
}

void main()
{
	uint xPixel = gl_LocalInvocationID.x + (gl_WorkGroupID.x * gl_WorkGroupSize.x);
	uint yPixel = gl_LocalInvocationID.y + (gl_WorkGroupID.y * gl_WorkGroupSize.y);
	uint pixelIdx = xPixel + (yPixel * (gl_NumWorkGroups.x * gl_WorkGroupSize.x));
	uint pixelSeed = initSeed(pixelIdx + frameState.totalSamples * 1799);

	for (uint s = 0; s < frameState.samplesPerFrame; s++)
	{
		float xAA = xPixel + randomRange(pixelSeed, -0.5, 0.5);
		float yAA = yPixel + randomRange(pixelSeed, -0.5, 0.5);

		float u = xAA / camera.resolution.x;
		float v = yAA / camera.resolution.y;

		vec3 origin = camera.position + sampleDefocusDisk(pixelSeed);
		vec3 planePos = camera.firstPixel + u * camera.uVector + v * camera.vVector;
		vec3 direction = normalize(planePos - origin);

		Ray activeRay = newRay(origin, direction);

		vec3 energy = vec3(0);
		for (uint bounceCount = 0;;bounceCount++)
		{
			if (!intersectTLAS(activeRay))
			{
				energy += activeRay.transmission * sampleSkyColor(activeRay, sceneData.background);
				break;
			}

			vec3 I = rayHitPosition(activeRay);
			vec3 N = sceneNormal(activeRay);
			Material material = sceneMaterial(activeRay);

			if (materialIsLight(material))
			{
				energy += activeRay.transmission * materialEmittance(material);
				break;
			}

			float p = clamp(max(activeRay.transmission.r, max(activeRay.transmission.g, activeRay.transmission.b)), 0.0f, 1.0f);
			if (bounceCount <= 2)	// Don't RR on first 2 bounces
				p = 1.0;

			if (p < randomF32(pixelSeed))
				break;

			if (dot(activeRay.direction, N) > 0.0f)
				N *= -1;

			vec3 mediumScale = vec3(1.0);
			if (activeRay.inMedium)
				mediumScale = exp(material.absorption * -activeRay.depth);

			float rrScale = 1.0 / p;
			float r = randomF32(pixelSeed);
			if (r < material.reflectivity)
			{
				vec3 newDirection = reflect(activeRay.direction, N);
				vec3 newOrigin = I + F32_EPSILON * newDirection;
				Ray reflectRay = newRay(newOrigin, newDirection);

				activeRay.transmission *= material.albedo * mediumScale * rrScale;
				reflectRay.pixelIdx = activeRay.pixelIdx;
				reflectRay.inMedium = activeRay.inMedium;
				reflectRay.transmission = activeRay.transmission;
				activeRay = reflectRay;
			}
			else if (r < (material.reflectivity + material.refractivity))
			{
				float n1 = activeRay.inMedium ? material.indexOfRefraction : 1.0f;
				float n2 = activeRay.inMedium ? 1.0f : material.indexOfRefraction;
				float iorRatio = n1 / n2;

				float cosI = dot(-activeRay.direction, N);
				float cosTheta2 = 1.0f - iorRatio * iorRatio * (1.0f - cosI * cosI);
				float Fresnel = 1.0f;
				if (cosTheta2 > 0.0f)
				{
					float a = n1 - n2;
					float b = n1 + n2;
					float r0 = (a * a) / (b * b);
					float c = 1.0f - cosI;
					float Fresnel = r0 + (1.0f - r0) * (c * c * c * c * c);

					vec3 newDirection = iorRatio * activeRay.direction + ((iorRatio * cosI - sqrt(abs(cosTheta2))) * N);
					vec3 newOrigin = I + F32_EPSILON * newDirection;
					Ray transmitRay = newRay(newOrigin, newDirection);

					if (randomF32(pixelSeed) > Fresnel)
					{
						activeRay.transmission *= material.albedo * mediumScale * rrScale;
						transmitRay.pixelIdx = activeRay.pixelIdx;
						transmitRay.inMedium = !activeRay.inMedium;
						transmitRay.transmission = activeRay.transmission;
						activeRay = transmitRay;
						continue;
					}
				}

				vec3 newDirection = reflect(activeRay.direction, N);
				vec3 newOrigin = I + F32_EPSILON * newDirection;
				Ray reflectRay = newRay(newOrigin, newDirection);

				activeRay.transmission *= material.albedo * mediumScale * rrScale;
				reflectRay.pixelIdx = activeRay.pixelIdx;
				reflectRay.inMedium = activeRay.inMedium;
				reflectRay.transmission = activeRay.transmission;
				activeRay = reflectRay;
			}
			else
			{
				// handle diffuse BRDF
				vec3 newDirection = diffuseReflectCosineWeighted(pixelSeed, N);
				vec3 newOrigin = I + F32_EPSILON * newDirection;
				Ray bounceRay = newRay(newOrigin, newDirection);

				float cosTheta = dot(newDirection, N);
				float invCosTheta = 1.0 / cosTheta;
				vec3 brdf = material.albedo * F32_INV_PI;
				float inversePdf = F32_PI * invCosTheta;

				activeRay.transmission *= materialEmittance(material) + inversePdf * cosTheta * brdf * mediumScale * rrScale;
				bounceRay.pixelIdx = activeRay.pixelIdx;
				bounceRay.inMedium = activeRay.inMedium;
				bounceRay.transmission = activeRay.transmission;
				activeRay = bounceRay;
			}
		}

		accumulator[pixelIdx] += vec4(energy, 1);
	}

	float invSamples = 1.0 / frameState.totalSamples;
	vec4 outColor = accumulator[pixelIdx] * invSamples;

	imageStore(
		outputImage,
		ivec2(xPixel, yPixel),
		outColor
	);
}
